{
    //多版本模式的配置模板
    "reader": {
        "name": "hbasereader",
        "parameter": {
            // hbase 连接信息
            "hbaseConfig": {
                "hbase.zookeeper.quorum": "?",
                "hbase.zookeeper.property.clientPort": "?",
                "k3": "v3"
            },
            "table": "hbase_test_table",

            // 默认为 utf8,可以配置为 utf8,gbk
            "encoding": "utf8",

            /**
            mode 可能取值为：normal, multiVersionFixedColumn, multiVersionDynamicColumn

            multiVersionFixedColumn, multiVersionDynamicColumn 都属于多版本读取方式，读出的数据是 (rowkey, column, timestamp, value) 四元组形式， 所以目的对应的表结构应该类似于有四个字段，并且类型依次为：string,string,long,string. 在把 hbase 中的二进制读成 string 时，DataX 统一使用 Bytes.toStringBinary() 完成.此外，多版本读取时，一定会去读 rowkey,这时不能在 column 中配置 rowkey；不支持常量列. 配合多版本读取时使用的还有额外两个参数：maxVersion,rowkeyType）

            multiVersionDynamicColumn 表示根据用户指定的列族读取，不需要指定列名
            */

            "mode": "multiVersionDynamicColumn",
            // 约定-1为读取全部版本，不能配置为0或者1（因为0或者1，我们认为用户是想用 normal模式读取数据，而非多版本模式读取，二者差别很大，末尾会展示如果用 normal 模式读取，拼成的 Record 的结果），大于1则表示读取最新的对应个数的版本
            "maxVersion": -1,

            //不支持 Date 类型（是出于这个考虑：如果是时间类型，必然需要配置 dateFormat 格式，引入不必要复杂性）
            "rowkeyType":"string",

            // 多版本读取时，读出的数据是 (rowkey, column, timestamp, value) 四元组形式， 所以目的对应的表结构应该类似于
            // 有四个字段，并且类型依次为：string,string,long,string. 在把 hbase 中的二进制读成 string 时，统一使用 Bytes.toBinaryString() 完成.

            "columnFamily":["basicInfo","extendsInfo"],

            "range": {
                // 执行 startRowKey 和 endRowKey 的范围，如果不指定，则表示全表读取
                "startRowkey": "\\x0001",
                "endRowkey": "\\xffff",

                // 描述用户配置的 startRowkey/endRowkey 的字符串是否为二进制字符串。
                // 如果为 true, 则调用Bytes.toBytesBinary(String rowKey)把 rowkey 转换为 bytes[]
                // 如果为 false, 则调用Bytes.toBytes(String rowKey)
                "isBinaryRowkey":true
            }
        }
    }
}