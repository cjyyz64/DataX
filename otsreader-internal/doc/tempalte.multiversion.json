{
  "job": {
    "setting": {
      "speed": {
        //设置传输速度，单位为byte/s，DataX运行会尽可能达到该速度但是不超过它.
        "byte": 1048576
      }
      //出错限制
      "errorLimit": {
        //出错的record条数上限，当大于该值即报错。
        "record": 0,
        //出错的record百分比上限 1.0表示100%，0.02表示2%
        "percentage": 0.02
      }
    },
    "content": [
      {
        "reader": {
          "name": "otsreader-internal",
          "parameter": {
            "mode": "multiVersion",
            "endpoint":"",
            "accessId":"",
            "accessKey":"",
            "instanceName":"",
            "table": "",
            
            // 导出的范围，,读取的范围是[begin,end)，左闭右开的区间
            // begin小于end，表示正序读取数据
            // begin大于end，表示反序读取数据
            // begin和end不能相等
            // type支持的类型有如下几类：
            //   string、int、binary
            //   binary输入的方式采用二进制的Base64字符串形式传入
            //   INF_MIN 表示无限小
            //   INF_MAX 表示无限大
            "range":{
                // 可选，默认表示从无限小开始读取
                // 这个值的输入可以填写空数组，或者PK前缀，亦或者完整的PK，在正序读取数据时，默认填充PK后缀为INF_MIN，反序为INF_MAX
                // 例子：
                // 如果用户的表有2个PK，类型分别为string、int，那么如下3种输入都是合法，如：
                //   1. []                                --> 表示从表的开始位置读取
                //   2. [{"type":"string", "value":"a"}]  --> 表示从[{"type":"string", "value":"a"},{"type":"INF_MIN"}]
                //   3. [{"type":"string", "value":"a"},{"type":"INF_MIN"}]
                //
                // binary类型的PK列比较特殊，因为Json不支持直接输入二进制数，所以系统定义:用户如果要传入
                // 二进制，必须使用(Java)Base64.encodeBase64String方法，将二进制转换为一个可视化的字符串，然后将这个字符串填入value中
                // 例子(Java)：
                //   byte[] bytes = "hello".getBytes();  # 构造一个二进制数据，这里使用字符串hello的byte值
                //   String inputValue = Base64.encodeBase64String(bytes) # 调用Base64方法，将二进制转换为可视化的字符串
                //   上面的代码执行之后，可以获得inputValue为"aGVsbG8="
                //   最终写入配置：{"type":"binary","value" : "aGVsbG8="}
                
                "begin":[{"type":"string", "value":"a"},{"type":"INF_MIN"}],
                
                // 默认表示读取到无限大结束
                // 这个值得输入可以填写空数组，或者PK前缀，亦或者完整的PK，在正序读取数据时，默认填充PK后缀为INF_MIN，反序为INF_MAX
                // 可选
                "end":[{"type":"string", "value":"g"},{"type":"INF_MAX"}],
                
                // 当前用户数据较多时，需要开启并发导出，Split可以将当前范围的的数据按照切分点切分为多个并发任务
                // 可选
                //   1. split中的输入值只能PK的第一列（分片建），且值的类型必须和PartitionKey一致
                //   2. 值的范围必须在begin和end之间
                //   3. split内部的值必须根据begin和end的正反序关系而递增或者递减
                "split":[{"type":"string", "value":"b"}, {"type":"string", "value":"c"}]
            },
            
            // 指定要导出的列，在多版本模式下只支持普通列
            // 格式：
            //   普通列格式：{"name":"{your column name}"}
            // 可选，默认导出所有列的所有版本
            // 注意：
            //   1.在多版本模式下，不支持常量列
            //   2.PK列不能指定，导出4元组中默认包括完整的PK
            //   3.不能重复指定列
            "column": [
                {"name":"attr1"}
            ],
            
            // 请求数据的Time Range,读取的范围是[begin,end)，左闭右开的区间
            // 可选，默认读取全部版本
            // 注意：begin必须小于end
            "timeRange":{
                // 可选，默认为0
                // 取值范围是0~LONG_MAX
                "begin":1400000000,
                // 可选，默认为Long Max(9223372036854775807L)
                // 取值范围是0~LONG_MAX
                "end"  :1600000000
            },
        
            // 请求的指定Version
            // 可选，默认读取所有版本
            // 取值范围是1~INT32_MAX
            "maxVersion":10,
          }
        },
        "writer": {
          //writer类型
          "name": "streamwriter",
          //是否打印内容
          "parameter": {
            "print": true
          }
        }
      }
    ]
  }
}